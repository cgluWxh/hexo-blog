---
title: 补发：2019年4月20日测试解题报告
date: 2019-08-14 20:47
tags: [解题报告,字符串]
categories: C++算法学习,日常做题、比赛笔记
---

# 字符串（string）
![](https://i.loli.net/2019/08/14/NQAdRhYb2zSMLJx.png)
## 算法分析
a) 暴力模拟删字符过程，先将每个人手里的串倒过来（不喜欢从前面删emmm）。然后从凡凡开始，先求出三个字符串长度，读最后一个字符判断下一个循环是谁删，然后令这个最后的字符为’\0’。

b) 流程图
![](https://i.loli.net/2019/08/14/ExIBYmays9lWwQr.png)

c) 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
 
char zifu[3][101];
const char pl[5]="ABC";
 
void ires(int a)
{
char temp[101];
int chlen=strlen(zifu[a]);
int wz=0;
for(int i=chlen-1;i>=0;i--)
{
temp[wz]=zifu[a][i];
wz++;
}
chlen=strlen(zifu[a]);
for(int i=0;i<chlen;i++)
{
zifu[a][i]=temp[i];
}
}
 
int main() {
freopen("string.in","r",stdin);
freopen("string.out","w",stdout); 
int player=0;
cin>>zifu[0]>>zifu[1]>>zifu[2];
ires(0);
ires(1);
ires(2);
while(1) {
int chlen=strlen(zifu[player]);
if(chlen==0){
cout<<pl[player];
break;
}
if(zifu[player][chlen-1]=='a')
{
zifu[player][chlen-1]='\0';
player=0;
}
else if(zifu[player][chlen-1]=='b')
{
zifu[player][chlen-1]='\0';
player=1;
}
else if(zifu[player][chlen-1]=='c')
{
zifu[player][chlen-1]='\0';
player=2;
}
}
}
```

# 汉堡包（hamburger）
![](https://i.loli.net/2019/08/14/kTziJBu7I1j8Sog.png)
## 算法分析
a) 首先很明显，这题用递归，汉堡中间套汉堡。程序过程：如果这是汉堡中的最后一层，那么直接输出最里面夹的这个汉堡，否则判断当前输出的是否是当前汉堡的最后一个字符，如果是，先输出这个汉堡的一个字符，然后输出夹层汉堡。

b) 流程图
![](https://i.loli.net/2019/08/14/n4ZCGh7rxiPToU9.png)

c) 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
char hb[12][12];
int flag=1;
 
void fun(int n)
{
if(flag==1)cin>>hb[n];
if(n==1){
cout<<hb[n];flag=0;}
else{
int templen=strlen(hb[n]);
for(int i=0;i<templen;i++)
{
cout<<hb[n][i];
if(i!=templen-1)fun(n-1);
}
}
}
 
int main()
{
freopen("hamburger.in","r",stdin);
freopen("hamburger.out","w",stdout);
int n;
cin>>n;
fun(n);
cout<<endl;
return 0;
}
```
