---
title: 2019年8月14日——广度优先搜索的应用
date: 2019-08-14 13:41
tags: [解题报告,搜索,bfs]
categories: C++算法学习,日常做题、比赛笔记
---

# 猴群
![](https://i.loli.net/2019/08/14/pGJlZE3h5U98xzQ.png)
![](https://i.loli.net/2019/08/14/mYWCPG92xBb785q.png)
**初次得分：100分**
## 算法分析
每当扫描到一只猴子时，就将这只猴子统计为一个猴群，删除周围上下左右相连的所有的猴子。
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,a[105][105],temp,ans;
int movex[4]={0,0,1,-1},movey[4]={1,-1,0,0};

void __search(int x,int y)
{
	a[x][y]=-1;
	for(int ax=0;ax<4;ax++)
	{
		if(a[x+movex[ax]][y+movey[ax]]==1)
		{
			__search(x+movex[ax],y+movey[ax]);
		}
	}
	return;
}

int main()
{
	freopen("monkey.in","r",stdin);
	freopen("monkey.out","w",stdout);
	cin>>m>>n;
	for(int i=0;i<=m+1;i++)
	{
		for(int j=0;j<=n+1;j++)
		{
			if(i==0||j==0||i==m+1||j==n+1)a[i][j]=0;
			else{
				scanf("%1d",&temp);
				if(temp==0)
				{
					a[i][j]=0;
				}
				else a[i][j]=1;
			}
		}
	}
	for(int i=1;i<=m;i++)
	{
		for(int j=1;j<=n;j++)
		{
			if(a[i][j]==1)
			{
				ans++;
				__search(i,j);
			}
		}
	}
	cout<<ans<<endl;
}
```
**注：本题来源lg1451**
# 奇怪的电梯
![](https://i.loli.net/2019/08/14/bkywg9GxNVp8YOq.png)
**初次得分：70分（共10个测试数据，正确7个，超时3个）**
## 算法分析
初次思考时打了一个纯模拟，用结构体的队列来模拟电梯往上往下，结果超时了。

但是呢，我听了一个同学的建议，把到达每个楼层所用的次数从队列中拿出来单独拿一个数组存，就对了...
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,k[201],flag[201],flagx=1,steps[201];

queue<int> x1;

int main()
{
	freopen("lift.in","r",stdin);
	freopen("lift.out","w",stdout);
	cin>>n>>a>>b;
	for(int i=1;i<=n;i++)
	{
		cin>>k[i];
	}
	x1.push(a);
	flag[a]=true;
	steps[a]=0;
	while(x1.empty()==0)
	{
		int xy=x1.front();
		x1.pop();
		if(xy==b){
			flagx=0;
			break;
		}
		int shang=xy+k[xy];
		if(shang<=n&&flag[shang]==0)
		{
			steps[shang]=steps[xy]+1;
			flag[shang]=1;
			x1.push(shang);
		}
		
		int xia=xy-k[xy];
		if(xia>=1&&flag[xia]==0)
		{
			steps[xia]=steps[xy]+1;
			flag[xia]=1;
			x1.push(xia);
		}
	}
	if(flagx)cout<<-1<<endl;
	else cout<<steps[b]<<endl;
	return 0;
}
```
**注：本题来源lg1135**
# 龙&虫
![](https://i.loli.net/2019/08/14/vmcFhMeTtuDp1sf.png)
![](https://i.loli.net/2019/08/14/hEnVSZJyFlaLpvG.png)
**初次得分：0（没做......）**
## 算法分析
Coming soon...
## 代码
Coming soon...
**本题来源：lg2199**
# 警察找车
![](https://i.loli.net/2019/08/14/ncgdtJYrmLvfPHI.png)
![](https://i.loli.net/2019/08/14/PbMaAVsEn4TpmkB.png)
**初次得分：0（代码不完整）**
## 算法分析
读入一个方向后就将从上一个方向走到的所有点（或初始点）沿着这个方向所有有可能走到的点再次存入，读取最后得到的所有点位置进行标记星号即可。
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;

char __map[55][55];
string temp;
set<pair<int,int > > a;
int move,moved[4][2]={{-1,0},{1,0},{0,-1},{0,1}};

void sign(register int x,register int y)
{
	__map[x][y]='*';
	return;
}

int main()
{
	register int r,c,n;
	scanf("%d%d\n",&r,&c);
	for(register int i=0;i<=r+1;i++)
	{
		for(register int j=0;j<=c+1;j++)
		{
			if(i==0||j==0||i==r+1||j==c+1)__map[i][j]='X';
			else{
				if(j==c)scanf("%c\n",&__map[i][j]);
				else scanf("%c",&__map[i][j]);
			}
		}
	}
	for(register int i=1;i<=r;i++)
	{
		for(register int j=1;j<=c;j++)
		{
			if(__map[i][j]=='*'){
				__map[i][j]='.';
				a.insert(make_pair(i,j));
				break;
			}
		}
	}
	cin>>n;
	for(register int i=0;i<n;i++)
	{
		cin>>temp;
		if(temp=="NORTH")move=0;
		else if(temp=="SOUTH")move=1;
		else if(temp=="WEST")move=2;
		else if(temp=="EAST")move=3;
		set<pair<int,int > > tmp(a);
		a.clear();
		for(set<pair<int,int> >::iterator it=tmp.begin();it!=tmp.end();it++)
		{
			int x=it->first;
			int y=it->second;
			for(int moving_x=x+moved[move][0],moving_y=y+moved[move][1];;moving_x+=moved[move][0],moving_y+=moved[move][1])
			{
				if(__map[moving_x][moving_y]!='X')
				{
					a.insert(make_pair(moving_x,moving_y));
				}
				else break;
			}
		}	
	}
	for(set<pair<int,int> >::iterator it=a.begin();it!=a.end();it++)
	{
		int x=it->first;
		int y=it->second;
		sign(x,y);
	}
	for(int i=1;i<=r;i++)
	{
		for(int j=1;j<=c;j++)
		{
			cout<<__map[i][j];
		}
		cout<<endl;
	}
	return 0;
}
```
**本题来源：lg1189**
# 奇怪的电视
![](https://i.loli.net/2019/08/14/VGgCMehyBNUf1O2.png)
![](https://i.loli.net/2019/08/14/mwuNIr84hBJPxKe.png)
**初次得分：0（未做）**
## 算法分析
广度优先搜索，每次用当前状态按下一个按钮拓展出下一个状态。直到达到目标状态。

**使用类hash方法，将当前状态的二进制转换为十进制来判断重复和判断是否正确。**
## 代码
``` cpp
#include<bits/stdc++.h>
using namespace std;
int a[1048577][21],t[100],b[100][100],step[1048577];
bool flag[1048577];
int n;
int ans=2000000;
int head,tail;
inline void click(register int x,register int head,register int tail)
{
	for(register int i=1;i<=n;i=-~i)
		a[tail][i]=a[head][i]; 
	a[tail][x]=1;
	for(register int i=1;i<=t[x];i=-~i)
		a[tail][b[x][i]]=0;
	step[tail]=step[head]+1; 
}
int __2to10(register int tail)
{
	register int mi,ret;
	mi=1;
	ret=0;
	for(register int i=1;i<=n;i=-~i){
		ret=ret+mi*a[tail][i];
		mi=mi*2;
	}
	return ret;
}

inline void search()
{

	register int status; 
	while(head<=tail){
		for(register int i=1;i<=n;i=-~i)
			if(a[head][i]==0)
			{
				tail=-~tail;
				click(i,head,tail);
				status=__2to10(tail); 
				if(flag[status]==false)
				{
					flag[status]=true;
					if(status==4)
						return;
				}
				else tail--;
			}
		head=-~head;
	}
}
int main()
{
	freopen("tv.in","r",stdin);
	freopen("tv.out","w",stdout);
	cin>>n;
	for(register int i=1;i<=n;i=-~i)
		cin>>a[0][i];
	head=0;tail=0;
	step[0]=0;
	register int status=__2to10(0);
	flag[status]=true;
	for(register int i=1;i<=n;i=-~i)
	{
		cin>>t[i];
		for(register int j=1;j<=t[i];j=-~j)
		{
			cin>>b[i][j];
		}
	}
	search();
	if(__2to10(tail)==4)
		cout<<step[tail];
	else
		cout<<-1;
	return 0;
} 
```
**本题来源：luo-hustoj2007**
# 勇士
![](https://i.loli.net/2019/08/14/NWpnPjR5uem4zHF.png)
![](https://i.loli.net/2019/08/14/ItLsvBR7WzbKxVO.png)
**初次得分：0（未做）**
## 算法分析
Coming soon...
## 代码
Coming soon...
**题目来源：未在任何Online Judge平台找到，但找到`http://blog.sina.com.cn/s/blog_142729a750102xvdz.html`**
# 棋盘
![](https://i.loli.net/2019/08/14/yzoLhBPnHjdTxfJ.png)
![](https://i.loli.net/2019/08/14/b3x2fpnrs8Ojkmh.png)
**初次得分：0（未做）**
## 算法分析
Coming soon...
## 代码
Coming soon...
**题目来源：NOIp普及组2017，lg3956**
